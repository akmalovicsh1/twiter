/* eslint-disable no-dupe-class-members, @typescript-eslint/no-misused-new */
import type {Observable} from 'rxjs'

export type AssetMetadataType =
  | 'location'
  | 'exif'
  | 'image'
  | 'palette'
  | 'lqip'
  | 'blurhash'
  | 'none'
export type DatasetAclMode = 'public' | 'private' | 'custom'
export type ListenVisibility = 'sync' | 'async' | 'query'
export type ListenEventName = 'mutation' | 'welcome' | 'reconnect'
export type MutationOperation = 'create' | 'delete' | 'update' | 'none'

export interface ResponseEvent<T = unknown> {
  type: 'response'
  body: T
  url: string
  method: string
  statusCode: number
  statusMessage?: string
  headers: Record<string, string>
}

export interface ProgressEvent {
  type: 'progress'
  stage: 'upload' | 'download'
  percent: number
  total?: number
  loaded?: number
  lengthComputable: boolean
}

type AttributeSet = {[key: string]: any}
type QueryParams = {[key: string]: any}
type MutationSelection = {query: string; params?: QueryParams} | {id: string}
type SanityReference = {_ref: string}

interface RawRequestOptions {
  url?: string
  uri?: string
  method?: string
  token?: string
  json?: boolean
  tag?: string
  useGlobalApi?: boolean
  withCredentials?: boolean
  query?: {[key: string]: string | string[]}
  headers?: {[key: string]: string}
  timeout?: number
  proxy?: string
  body?: any
  maxRedirects?: number
}

interface AuthProvider {
  name: string
  title: string
  url: string
}

interface SanityUser {
  id: string
  projectId: string
  displayName: string
  familyName: string | null
  givenName: string | null
  middleName: string | null
  imageUrl: string | null
  createdAt: string
  updatedAt: string
  isCurrentUser: boolean
}

interface CurrentSanityUser {
  id: string
  name: string
  email: string
  profileImage: string | null
  role: string
}

interface SanityProjectMember {
  id: string
  role: string
  isRobot: boolean
  isCurrentUser: boolean
}

interface SanityProject {
  id: string
  displayName: string
  studioHost: string | null
  organizationId: string | null
  isBlocked: boolean
  isDisabled: boolean
  isDisabledByUser: boolean
  createdAt: string
  pendingInvites?: number
  maxRetentionDays?: number
  members: SanityProjectMember[]
  metadata: {
    color?: string
    externalStudioHost?: string
  }
}

type GetItRequester = {
  use: (middleware: any) => GetItRequester
  clone(): GetItRequester
}

export interface UploadOptions {
  /**
   * Optional request tag for the upload
   */
  tag?: string

  /**
   * Whether or not to preserve the original filename (default: true)
   */
  preserveFilename?: boolean

  /**
   * Filename for this file (optional)
   */
  filename?: string

  /**
   * Milliseconds to wait before timing the request out
   */
  timeout?: number

  /**
   * Mime type of the file
   */
  contentType?: string

  /**
   * Array of metadata parts to extract from asset
   */
  extract?: AssetMetadataType[]

  /**
   * Optional freeform label for the asset. Generally not used.
   */
  label?: string

  /**
   * Optional title for the asset
   */
  title?: string

  /**
   * Optional description for the asset
   */
  description?: string

  /**
   * The credit to person(s) and/or organization(s) required by the supplier of the asset to be used when published
   */
  creditLine?: string

  /**
   * Source data (when the asset is from an external service)
   */
  source?: {
    /**
     * The (u)id of the asset within the source, i.e. 'i-f323r1E'
     */
    id: string

    /**
     * The name of the source, i.e. 'unsplash'
     */
    name: string

    /**
     * A url to where to find the asset, or get more info about it in the source
     */
    url?: string
  }
}

export type InsertPatch =
  | {before: string; items: any[]}
  | {after: string; items: any[]}
  | {replace: string; items: any[]}

// Note: this is actually incorrect/invalid, but implemented as-is for backwards compatibility
export interface PatchOperations {
  set?: {[key: string]: any}
  setIfMissing?: {[key: string]: any}
  diffMatchPatch?: {[key: string]: any}
  unset?: string[]
  inc?: {[key: string]: number}
  dec?: {[key: string]: number}
  insert?: InsertPatch
  ifRevisionID?: string
}

export type PatchBuilder = (patch: Patch) => Patch

export type PatchMutationOperation = PatchOperations & MutationSelection

export type Mutation<R extends Record<string, any> = Record<string, any>> =
  | {create: SanityDocumentStub<R>}
  | {createOrReplace: IdentifiedSanityDocumentStub<R>}
  | {createIfNotExists: IdentifiedSanityDocumentStub<R>}
  | {delete: MutationSelection}
  | {patch: PatchMutationOperation}

export interface SingleMutationResult {
  transactionId: string
  documentId: string
  results: {id: string; operation: MutationOperation}[]
}

export interface MultipleMutationResult {
  transactionId: string
  documentIds: string[]
  results: {id: string; operation: MutationOperation}[]
}

export abstract class BasePatch {
  /**
   * DEPRECATED: Don't use.
   * The operation is added to the current patch, ready to be commited by `commit()`
   *
   * @deprecated
   * @param attrs Attributes to replace
   */
  replace(attrs: AttributeSet): this

  /**
   * Sets the given attributes to the document. Does NOT merge objects.
   * The operation is added to the current patch, ready to be commited by `commit()`
   *
   * @param attrs Attributes to set. To set a deep attribute, use JSONMatch, eg: {"nested.prop": "value"}
   */
  set(attrs: AttributeSet): this

  /**
   * Sets the given attributes to the document if they are not currently set. Does NOT merge objects.
   * The operation is added to the current patch, ready to be commited by `commit()`
   *
   * @param attrs Attributes to set. To set a deep attribute, use JSONMatch, eg: {"nested.prop": "value"}
   */
  setIfMissing(attrs: AttributeSet): this

  /**
   * Performs a "diff-match-patch" operation on the string attributes provided.
   * The operation is added to the current patch, ready to be commited by `commit()`
   *
   * @param attrs Attributes to perform operation on. To set a deep attribute, use JSONMatch, eg: {"nested.prop": "dmp"}
   */
  diffMatchPatch(attrs: AttributeSet): this

  /**
   * Unsets the attribute paths provided.
   * The operation is added to the current patch, ready to be commited by `commit()`
   *
   * @param attrs Attribute paths to unset.
   */
  unset(attrs: string[]): this

  /**
   * Increment a numeric value. Each entry in the argument is either an attribute or a JSON path. The value may be a positive or negative integer or floating-point value. The operation will fail if target value is not a numeric value, or doesn't exist.
   *
   * @param attrs Object of attribute paths to increment, values representing the number to increment by.
   */
  inc(attrs: {[key: string]: number}): this

  /**
   * Decrement a numeric value. Each entry in the argument is either an attribute or a JSON path. The value may be a positive or negative integer or floating-point value. The operation will fail if target value is not a numeric value, or doesn't exist.
   *
   * @param attrs Object of attribute paths to decrement, values representing the number to decrement by.
   */
  dec(attrs: {[key: string]: number}): this

  /**
   * Provides methods for modifying arrays, by inserting, appending and replacing elements via a JSONPath expression.
   *
   * @param at Location to insert at, relative to the given selector, or 'replace' the matched path
   * @param selector JSONPath expression, eg `comments[-1]` or `blocks[_key=="abc123"]`
   * @param items Array of items to insert/replace
   */
  insert(at: 'before' | 'after' | 'replace', selector: string, items: any[]): this

  /**
   * Append the given items to the array at the given JSONPath
   *
   * @param selector Attribute/path to append to, eg `comments` or `person.hobbies`
   * @param items Array of items to append to the array
   */
  append(selector: string, items: any[]): this

  /**
   * Prepend the given items to the array at the given JSONPath
   *
   * @param selector Attribute/path to prepend to, eg `comments` or `person.hobbies`
   * @param items Array of items to prepend to the array
   */
  prepend(selector: string, items: any[]): this

  /**
   * Change the contents of an array by removing existing elements and/or adding new elements.
   *
   * @param selector Attribute or JSONPath expression for array
   * @param start Index at which to start changing the array (with origin 0). If greater than the length of the array, actual starting index will be set to the length of the array. If negative, will begin that many elements from the end of the array (with origin -1) and will be set to 0 if absolute value is greater than the length of the array.x
   * @param deleteCount An integer indicating the number of old array elements to remove.
   * @param items The elements to add to the array, beginning at the start index. If you don't specify any elements, splice() will only remove elements from the array.
   */
  splice(selector: string, start: number, deleteCount: number, items: any[]): this

  /**
   * Adds a revision clause, preventing the document from being patched if the `_rev` property does not match the given value
   *
   * @param rev Revision to lock the patch to
   */
  ifRevisionId(rev: string): this

  /**
   * Return a plain JSON representation of the patch
   */
  serialize(): PatchMutationOperation

  /**
   * Return a plain JSON representation of the patch
   */
  toJSON(): PatchMutationOperation

  /**
   * Clears the patch of all operations
   */
  reset(): this
}

export class Patch extends BasePatch {
  constructor(documentId: string, operations?: PatchOperations, client?: SanityClient)

  /**
   * Clones the patch
   */
  clone(): Patch

  /**
   * Commit the patch, returning a promise that resolves to the first patched document
   *
   * @param options Options for the mutation operation
   */
  commit<R extends Record<string, any> = Record<string, any>>(
    options: FirstDocumentMutationOptions
  ): Promise<SanityDocument<R>>

  /**
   * Commit the patch, returning a promise that resolves to an array of the mutated documents
   *
   * @param options Options for the mutation operation
   */
  commit<R extends Record<string, any> = Record<string, any>>(
    options: AllDocumentsMutationOptions
  ): Promise<SanityDocument<R>[]>

  /**
   * Commit the patch, returning a promise that resolves to a mutation result object
   *
   * @param options Options for the mutation operation
   */
  commit(options: FirstDocumentIdMutationOptions): Promise<SingleMutationResult>

  /**
   * Commit the patch, returning a promise that resolves to a mutation result object
   *
   * @param options Options for the mutation operation
   */
  commit(options: AllDocumentIdsMutationOptions): Promise<MultipleMutationResult>

  /**
   * Commit the patch, returning a promise that resolves to the first patched document
   *
   * @param options Options for the mutation operation
   */
  commit<R extends Record<string, any> = Record<string, any>>(
    options?: BaseMutationOptions
  ): Promise<SanityDocument<R>>
}

export class ObservablePatch extends BasePatch {
  constructor(documentId: string, operations?: PatchOperations, client?: ObservableSanityClient)

  /**
   * Clones the patch
   */
  clone(): ObservablePatch

  /**
   * Commit the patch, returning an observable that produces the first patched document
   *
   * @param options Options for the mutation operation
   */
  commit<R extends Record<string, any> = Record<string, any>>(
    options: FirstDocumentMutationOptions
  ): Observable<SanityDocument<R>>

  /**
   * Commit the patch, returning an observable that produces an array of the mutated documents
   *
   * @param options Options for the mutation operation
   */
  commit<R extends Record<string, any> = Record<string, any>>(
    options: AllDocumentsMutationOptions
  ): Observable<SanityDocument<R>[]>

  /**
   * Commit the patch, returning an observable that produces a mutation result object
   *
   * @param options Options for the mutation operation
   */
  commit(options: FirstDocumentIdMutationOptions): Observable<SingleMutationResult>

  /**
   * Commit the patch, returning an observable that produces a mutation result object
   *
   * @param options Options for the mutation operation
   */
  commit(options: AllDocumentIdsMutationOptions): Observable<MultipleMutationResult>

  /**
   * Commit the patch, returning an observable that produces the first patched document
   *
   * @param options Options for the mutation operation
   */
  commit<R extends Record<string, any> = Record<string, any>>(
    options?: BaseMutationOptions
  ): Observable<SanityDocument<R>>
}

export abstract class BaseTransaction {
  /**
   * Creates a new Sanity document. If `_id` is provided and already exists, the mutation will fail. If no `_id` is given, one will automatically be generated by the database.
   * The operation is added to the current transaction, ready to be commited by `commit()`
   *
   * @param doc Document to create. Requires a `_type` property.
   */
  create<R extends Record<string, any> = Record<string, any>>(doc: SanityDocumentStub<R>): this

  /**
   * Creates a new Sanity document. If a document with the same `_id` already exists, the create operation will be ignored.
   * The operation is added to the current transaction, ready to be commited by `commit()`
   *
   * @param doc Document to create if it does not already exist. Requires `_id` and `_type` properties.
   */
  createIfNotExists<R extends Record<string, any> = Record<string, any>>(
    doc: IdentifiedSanityDocumentStub<R>
  ): this

  /**
   * Creates a new Sanity document, or replaces an existing one if the same `_id` is already used.
   * The operation is added to the current transaction, ready to be commited by `commit()`
   *
   * @param doc Document to create or replace. Requires `_id` and `_type` properties.
   */
  createOrReplace<R extends Record<string, any> = Record<string, any>>(
    doc: IdentifiedSanityDocumentStub<R>
  ): this

  /**
   * Deletes the document with the given document ID
   * The operation is added to the current transaction, ready to be commited by `commit()`
   *
   * @param documentId Document ID to delete
   */
  delete(documentId: string): this

  /**
   * Performs a patch on the given document ID. Can either be a builder function or an object of patch operations.
   * The operation is added to the current transaction, ready to be commited by `commit()`
   *
   * @param documentId Document ID to perform the patch operation on
   * @param patchOps Operations to perform, or a builder function
   */
  patch(documentId: string, patchOps?: PatchBuilder | PatchOperations): this

  /**
   * Adds the given patch instance to the transaction.
   * The operation is added to the current transaction, ready to be commited by `commit()`
   *
   * @param patch Patch to execute
   */
  patch(patch: Patch): this

  /**
   * Set or gets the ID of this transaction.
   * Should generally not be specified.
   * If no ID is specified, the currently configured ID will be returned, if any.
   *
   * @param id Transaction ID
   */
  transactionId<T extends string | undefined>(id: T): T extends string ? this : string | undefined

  /**
   * Return a plain JSON representation of the transaction
   */
  serialize(): Mutation[]

  /**
   * Return a plain JSON representation of the transaction
   */
  toJSON(): Mutation[]

  /**
   * Clears the transaction of all operations
   */
  reset(): this
}

export class Transaction extends BaseTransaction {
  constructor(operations?: Mutation[], client?: SanityClient, transactionId?: string)

  /**
   * Clones the transaction
   */
  clone(): Transaction

  /**
   * Commit the transaction, returning a promise that resolves to the first mutated document
   *
   * @param options Options for the mutation operation
   */
  commit<R extends Record<string, any>>(
    options: TransactionFirstDocumentMutationOptions
  ): Promise<SanityDocument<R>>

  /**
   * Commit the transaction, returning a promise that resolves to an array of the mutated documents
   *
   * @param options Options for the mutation operation
   */
  commit<R extends Record<string, any>>(
    options: TransactionAllDocumentsMutationOptions
  ): Promise<SanityDocument<R>[]>

  /**
   * Commit the transaction, returning a promise that resolves to a mutation result object
   *
   * @param options Options for the mutation operation
   */
  commit(options: TransactionFirstDocumentIdMutationOptions): Promise<SingleMutationResult>

  /**
   * Commit the transaction, returning a promise that resolves to a mutation result object
   *
   * @param options Options for the mutation operation
   */
  commit(options: TransactionAllDocumentIdsMutationOptions): Promise<MultipleMutationResult>

  /**
   * Commit the transaction, returning a promise that resolves to a mutation result object
   *
   * @param options Options for the mutation operation
   */
  commit(options?: BaseMutationOptions): Promise<MultipleMutationResult>
}

export class ObservableTransaction extends BaseTransaction {
  constructor(operations?: Mutation[], client?: ObservableSanityClient, transactionId?: string)

  /**
   * Clones the transaction
   */
  clone(): ObservableTransaction

  /**
   * Commit the transaction, returning an observable that produces the first mutated document
   *
   * @param options Options for the mutation operation
   */
  commit<R extends Record<string, any>>(
    options: TransactionFirstDocumentMutationOptions
  ): Observable<SanityDocument<R>>

  /**
   * Commit the transaction, returning an observable that produces an array of the mutated documents
   *
   * @param options Options for the mutation operation
   */
  commit<R extends Record<string, any>>(
    options: TransactionAllDocumentsMutationOptions
  ): Observable<SanityDocument<R>[]>

  /**
   * Commit the transaction, returning an observable that produces a mutation result object
   *
   * @param options Options for the mutation operation
   */
  commit(options: TransactionFirstDocumentIdMutationOptions): Observable<SingleMutationResult>

  /**
   * Commit the transaction, returning an observable that produces a mutation result object
   *
   * @param options Options for the mutation operation
   */
  commit(options: TransactionAllDocumentIdsMutationOptions): Observable<MultipleMutationResult>

  /**
   * Commit the transaction, returning an observable that produces a mutation result object
   *
   * @param options Options for the mutation operation
   */
  commit(options?: BaseMutationOptions): Observable<MultipleMutationResult>
}

export interface ClientConfig {
  projectId?: string
  dataset?: string
  useCdn?: boolean
  token?: string
  apiHost?: string
  apiVersion?: string
  proxy?: string
  requestTagPrefix?: string
  ignoreBrowserTokenWarning?: boolean
  withCredentials?: boolean
  allowReconfigure?: boolean
  timeout?: number

  /**
   * @deprecated Don't use
   */
  useProjectHostname?: boolean

  /**
   * @deprecated Don't use
   */
  requester?: GetItRequester
}

/**
 * @deprecated Don't use
 */
export type ProjectlessClientConfig = ClientConfig & {useProjectHostname: false}

/**
 * @deprecated Don't use
 */
export type ProjectClientConfig = ClientConfig & {
  useProjectHostname?: true
  projectId: string
}

export interface RequestOptions {
  timeout?: number
  token?: string
  tag?: string
  headers?: Record<string, string>
}

type BaseMutationOptions = RequestOptions & {
  visibility?: 'sync' | 'async' | 'deferred'
  returnDocuments?: boolean
  returnFirst?: boolean
  dryRun?: boolean
  autoGenerateArrayKeys?: boolean
  skipCrossDatasetReferenceValidation?: boolean
}

export type MutationEvent<R extends Record<string, any> = Record<string, any>> = {
  type: 'mutation'
  documentId: string
  eventId: string
  identity: string
  m