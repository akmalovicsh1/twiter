'use strict'

const tape = require('tape')
const crypto = require('crypto')
const fs = require('fs')
const path = require('path')
const BufferList = require('../')
const { Buffer } = require('buffer')

const encodings =
      ('hex utf8 utf-8 ascii binary base64' +
          (process.browser ? '' : ' ucs2 ucs-2 utf16le utf-16le')).split(' ')

require('./indexOf')
require('./isBufferList')
require('./convert')

tape('single bytes from single buffer', function (t) {
  const bl = new BufferList()

  bl.append(Buffer.from('abcd'))

  t.equal(bl.length, 4)
  t.equal(bl.get(-1), undefined)
  t.equal(bl.get(0), 97)
  t.equal(bl.get(1), 98)
  t.equal(bl.get(2), 99)
  t.equal(bl.get(3), 100)
  t.equal(bl.get(4), undefined)

  t.end()
})

tape('single bytes from multiple buffers', function (t) {
  const bl = new BufferList()

  bl.append(Buffer.from('abcd'))
  bl.append(Buffer.from('efg'))
  bl.append(Buffer.from('hi'))
  bl.append(Buffer.from('j'))

  t.equal(bl.length, 10)

  t.equal(bl.get(0), 97)
  t.equal(bl.get(1), 98)
  t.equal(bl.get(2), 99)
  t.equal(bl.get(3), 100)
  t.equal(bl.get(4), 101)
  t.equal(bl.get(5), 102)
  t.equal(bl.get(6), 103)
  t.equal(bl.get(7), 104)
  t.equal(bl.get(8), 105)
  t.equal(bl.get(9), 106)

  t.end()
})

tape('multi bytes from single buffer', function (t) {
  const bl = new BufferList()

  bl.append(Buffer.from('abcd'))

  t.equal(bl.length, 4)

  t.equal(bl.slice(0, 4).toString('ascii'), 'abcd')
  t.equal(bl.slice(0, 3).toString('ascii'), 'abc')
  t.equal(bl.slice(1, 4).toString('ascii'), 'bcd')
  t.equal(bl.slice(-4, -1).toString('ascii'), 'abc')

  t.end()
})

tape('multi bytes from single buffer (negative indexes)', function (t) {
  const bl = new BufferList()

  bl.append(Buffer.from('buffer'))

  t.equal(bl.length, 6)

  t.equal(bl.slice(-6, -1).toString('ascii'), 'buffe')
  t.equal(bl.slice(-6, -2).toString('ascii'), 'buff')
  t.equal(bl.slice(-5, -2).toString('ascii'), 'uff')

  t.end()
})

tape('multiple bytes from multiple buffers', function (t) {
  const bl = new BufferList()

  bl.append(Buffer.from('abcd'))
  bl.append(Buffer.from('efg'))
  bl.append(Buffer.from('hi'))
  bl.append(Buffer.from('j'))

  t.equal(bl.length, 10)

  t.equal(bl.slice(0, 10).toString('ascii'), 'abcdefghij')
  t.equal(bl.slice(3, 10).toString('ascii'), 'defghij')
  t.equal(bl.slice(3, 6).toString('ascii'), 'def')
  t.equal(bl.slice(3, 8).toString('ascii'), 'defgh')
  t.equal(bl.slice(5, 10).toString('ascii'), 'fghij')
  t.equal(bl.slice(-7, -4).toString('ascii'), 'def')

  t.end()
})

tape('multiple bytes from multiple buffer lists', function (t) {
  const bl = new BufferList()

  bl.append(new BufferList([Buffer.from('abcd'), Buffer.from('efg')]))
  bl.append(new BufferList([Buffer.from('hi'), Buffer.from('j')]))

  t.equal(bl.length, 10)

  t.equal(bl.slice(0, 10).toString('ascii'), 'abcdefghij')

  t.equal(bl.slice(3, 10).toString('ascii'), 'defghij')
  t.equal(bl.slice(3, 6).toString('ascii'), 'def')
  t.equal(bl.slice(3, 8).toString('ascii'), 'defgh')
  t.equal(bl.slice(5, 10).toString('ascii'), 'fghij')

  t.end()
})

// same data as previous test, just using nested constructors
tape('multiple bytes from crazy nested buffer lists', function (t) {
  const bl = new BufferList()

  bl.append(new BufferList([
    new BufferList([
      new BufferList(Buffer.from('abc')),
      Buffer.from('d'),
      new BufferList(Buffer.from('efg'))
    ]),
    new BufferList([Buffer.from('hi')]),
    new BufferList(Buffer.from('j'))
  ]))

  t.equal(bl.length, 10)

  t.equal(bl.slice(0, 10).toString('ascii'), 'abcdefghij')

  t.equal(bl.slice(3, 10).toString('ascii'), 'defghij')
  t.equal(bl.slice(3, 6).toString('ascii'), 'def')
  t.equal(bl.slice(3, 8).toString('ascii'), 'defgh')
  t.equal(bl.slice(5, 10).toString('ascii'), 'fghij')

  t.end()
})

tape('append accepts arrays of Buffers', function (t) {
  const bl = new BufferList()

  bl.append(Buffer.from('abc'))
  bl.append([Buffer.from('def')])
  bl.append([Buffer.from('ghi'), Buffer.from('jkl')])
  bl.append([Buffer.from('mnop'), Buffer.from('qrstu'), Buffer.from('vwxyz')])
  t.equal(bl.length, 26)
  t.equal(bl.slice().toString('ascii'), 'abcdefghijklmnopqrstuvwxyz')

  t.end()
})

tape('append accepts arrays of Uint8Arrays', function (t) {
  const bl = new BufferList()

  bl.append(new Uint8Array([97, 98, 99]))
  bl.append([Uint8Array.from([100, 101, 102])])
  bl.append([new Uint8Array([103, 104, 105]), new Uint8Array([106, 107, 108])])
  bl.append([new Uint8Array([109, 110, 111, 112]), new Uint8Array([113, 114, 115, 116, 117]), new Uint8Array([118, 119, 120, 121, 122])])
  t.equal(bl.length, 26)
  t.equal(bl.slice().toString('ascii'), 'abcdefghijklmnopqrstuvwxyz')

  t.end()
})

tape('append accepts arrays of BufferLists', function (t) {
  const bl = new BufferList()

  bl.append(Buffer.from('abc'))
  bl.append([new BufferList('def')])
  bl.append(new BufferList([Buffer.from('ghi'), new BufferList('jkl')]))
  bl.append([Buffer.from('mnop'), new BufferList([Buffer.from('qrstu'), Buffer.from('vwxyz')])])
  t.equal(bl.length, 26)
  t.equal(bl.slice().toString('ascii'), 'abcdefghijklmnopqrstuvwxyz')

  t.end()
})

tape('append chainable', function (t) {
  const bl = new BufferList()

  t.ok(bl.append(Buffer.from('abcd')) === bl)
  t.ok(bl.append([Buffer.from('abcd')]) === bl)
  t.ok(bl.append(new BufferList(Buffer.from('abcd'))) === bl)
  t.ok(bl.append([new BufferList(Buffer.from('abcd'))]) === bl)

  t.end()
})

tape('append chainable (test results)', function (t) {
  const bl = new BufferList('abc')
    .append([new BufferList('def')])
    .append(new BufferList([Buffer.from('ghi'), new BufferList('jkl')]))
    .append([Buffer.from('mnop'), new BufferList([Buffer.from('qrstu'), Buffer.from('vwxyz')])])

  t.equal(bl.length, 26)
  t.equal(bl.slice().toString('ascii'), 'abcdefghijklmnopqrstuvwxyz')

  t.end()
})

tape('consuming from multiple buffers', function (t) {
  const bl = new BufferList()

  bl.append(Buffer.from('abcd'))
  bl.append(Buffer.from('efg'))
  bl.append(Buffer.from('hi'))
  bl.append(Buffer.from('j'))

  t.equal(bl.length, 10)

  t.equal(bl.slice(0, 10).toString('ascii'), 'abcdefghij')

  bl.consume(3)
  t.equal(bl.length, 7)
  t.equal(bl.slice(0, 7).toString('ascii'), 'defghij')

  bl.consume(2)
  t.equal(bl.length, 5)
  t.equal(bl.slice(0, 5).toString('ascii'), 'fghij')

  bl.consume(1)
  t.equal(bl.length, 4)
  t.equal(bl.slice(0, 4).toString('ascii'), 'ghij')

  bl.consume(1)
  t.equal(bl.length, 3)
  t.equal(bl.slice(0, 3).toString('ascii'), 'hij')

  bl.consume(2)
  t.equal(bl.length, 1)
  t.equal(bl.slice(0, 1).toString('ascii'), 'j')

  t.end()
})

tape('complete consumption', function (t) {
  const bl = new BufferList()

  bl.append(Buffer.from('a'))
  bl.append(Buffer.from('b'))

  bl.consume(2)

  t.equal(bl.length, 0)
  t.equal(bl._bufs.length, 0)

  t.end()
})

tape('test readUInt8 / readInt8', function (t) {
  const buf1 = Buffer.alloc(1)
  const buf2 = Buffer.alloc(3)
  const buf3 = Buffer.alloc(3)
  const bl = new BufferList()

  buf1[0] = 0x1
  buf2[1] = 0x3
  buf2[2] = 0x4
  buf3[0] = 0x23
  buf3[1] = 0x42

  bl.append(buf1)
  bl.append(buf2)
  bl.append(buf3)

  t.equal(bl.readUInt8(), 0x1)
  t.equal(bl.readUInt8(2), 0x3)
  t.equal(bl.readInt8(2), 0x3)
  t.equal(bl.readUInt8(3), 0x4)
  t.equal(bl.readInt8(3), 0x4)
  t.equal(bl.readUInt8(4), 0x23)
  t.equal(bl.readInt8(4), 0x23)
  t.equal(bl.readUInt8(5), 0x42)
  t.equal(bl.readInt8(5), 0x42)

  t.end()
})

tape('test readUInt16LE / readUInt16BE / readInt16LE / readInt16BE', function (t) {
  const buf1 = Buffer.alloc(1)
  const buf2 = Buffer.alloc(3)
  const buf3 = Buffer.alloc(3)
  const bl = new BufferList()

  buf1[0] = 0x1
  buf2[1] = 0x3
  buf2[2] = 0x4
  buf3[0] = 0x23
  buf3[1] = 0x42

  bl.append(buf1)
  bl.append(buf2)
  bl.append(buf3)

  t.equal(bl.readUInt16BE(), 0x0100)
  t.equal(bl.readUInt16LE(), 0x0001)
  t.equal(bl.readUInt16BE(2), 0x0304)
  t.equal(bl.readUInt16LE(2), 0x0403)
  t.equal(bl.readInt16BE(2), 0x0304)
  t.equal(bl.readInt16LE(2), 0x0403)
  t.equal(bl.readUInt16BE(3), 0x0423)
  t.equal(bl.readUInt16LE(3), 0x2304)
  t.equal(bl.readInt16BE(3), 0x0423)
  t.equal(bl.readInt16LE(3), 0x2304)
  t.equal(bl.readUInt16BE(4), 0x2342)
  t.equal(bl.readUInt16LE(4), 0x4223)
  t.equal(bl.readInt16BE(4), 0x2342)
  t.equal(bl.readInt16LE(4), 0x4223)

  t.end()
})

tape('test readUInt32LE / readUInt32BE / readInt32LE / readInt32BE', function (t) {
  const buf1 = Buffer.alloc(1)
  const buf2 = Buffer.alloc(3)
  const buf3 = Buffer.alloc(3)
  const bl = new BufferList()

  buf1[0] = 0x1
  buf2[1] = 0x3
  buf2[2] = 0x4
  buf3[0] = 0x23
  buf3[1] = 0x42

  bl.append(buf1)
  bl.append(buf2)
  bl.append(buf3)

  t.equal(bl.readUInt32BE(), 0x01000304)
  t.equal(bl.readUInt32LE(), 0x04030001)
  t.equal(bl.readUInt32BE(2), 0x03042342)
  t.equal(bl.readUInt32LE(2), 0x42230403)
  t.equal(bl.readInt32BE(2), 0x03042342)
  t.equal(bl.readInt32LE(2), 0x42230403)

  t.end()
})

tape('test readUIntLE / readUIntBE / readIntLE / readIntBE', function (t) {
  const buf1 = Buffer.alloc(1)
  const buf2 = Buffer.alloc(3)
  const buf3 = Buffer.alloc(3)
  const bl = new BufferList()

  buf2[0] = 0x2
  buf2[1] = 0x3
  buf2[2] = 0x4
  buf3[0] = 0x23
  buf3[1] = 0x42
  buf3[2] = 0x61

  bl.append(buf1)
  bl.append(buf2)
  bl.append(buf3)

  t.equal(bl.readUIntBE(1, 1), 0x02)
  t.equal(bl.readUIntBE(1, 2), 0x0203)
  t.equal(bl.readUIntBE(1, 3), 0x020304)
  t.equal(bl.readUIntBE(1, 4), 0x02030423)
  t.equal(bl.readUIntBE(1, 5), 0x0203042342)
  t.equal(bl.readUIntBE(1, 6), 0x020304234261)
  t.equal(bl.readUIntLE(1, 1), 0x02)
  t.equal(bl.readUIntLE(1, 2), 0x0302)
  t.equal(bl.readUIntLE(1, 3), 0x040302)
  t.equal(bl.readUIntLE(1, 4), 0x23040302)
  t.equal(bl.readUIntLE(1, 5), 0x4223040302)
  t.equal(bl.readUIntLE(1, 6), 0x614223040302)
  t.equal(bl.readIntBE(1, 1), 0x02)
  t.equal(bl.readIntBE(1, 2), 0x0203)
  t.equal(bl.readIntBE(1, 3), 0x020304)
  t.equal(bl.readIntBE(1, 4), 0x02030423)
  t.equal(bl.readIntBE(1, 5), 0x0203042342)
  t.equal(bl.readIntBE(1, 6), 0x020304234261)
  t.equal(bl.readIntLE(1, 1), 0x02)
  t.equal(bl.readIntLE(1, 2), 0x0302)
  t.equal(bl.readIntLE(1, 3), 0x040302)
  t.equal(bl.readIntLE(1, 4), 0x23040302)
  t.equal(bl.readIntLE(1, 5), 0x4223040302)
  t.equal(bl.readIntLE(1, 6), 0x614223040302)

  t.end()
})

tape('test readFloatLE / readFloatBE', function (t) {
  const buf1 = Buffer.alloc(1)
  const buf2 = Buffer.alloc(3)
  const buf3 = Buffer.alloc(3)
  const bl = new BufferList()

  buf1[0] = 0x01
  buf2[1] = 0x00
  buf2[2] = 0x00
  buf3[0] = 0x80
  buf3[1] = 0x3f

  bl.append(buf1)
  bl.append(buf2)
  bl.append(buf3)

  const canonical = Buffer.concat([buf1, buf2, buf3])
  t.equal(bl.readFloatLE(), canonical.readFloatLE())
  t.equal(bl.readFloatBE(), canonical.readFloatBE())
  t.equal(bl.readFloatLE(2), canonical.readFloatLE(2))
  t.equal(bl.readFloatBE(2), canonical.readFloatBE(2))

  t.end()
})

tape('test readDoubleLE / readDoubleBE', function (t) {
  const buf1 = Buffer.alloc(1)
  const buf2 = Buffer.alloc(3)
  const buf3 = Buffer.alloc(10)
  const bl = new BufferList()

  buf1[0] = 0x01
  buf2[1] = 0x55
  buf2[2] = 0x55
  buf3[0] = 0x55
  buf3[1] = 0x55
  buf3[2] = 0x55
  buf3[3] = 0x55
  buf3[4] = 0xd5
  buf3[5] = 0x3f

  bl.append(buf1)
  bl.append(buf2)
  bl.append(buf3)

  const canonical = Buffer.concat([buf1, buf2, buf3])
  t.equal(bl.readDoubleBE(), canonical.readDoubleBE())
  t.equal(bl.readDoubleLE(), canonical.readDoubleLE())
  t.equal(bl.readDoubleBE(2), canonical.readDoubleBE(2))
  t.equal(bl.readDoubleLE(2), canonical.readDoubleLE(2))

  t.end()
})

tape('test toString', function (t) {
  const bl = new BufferList()

  bl.append(Buffer.from('abcd'))
  bl.append(Buffer.from('efg'))
  bl.append(Buffer.from('hi'))
  bl.append(Buffer.from('j'))

  t.equal(bl.toString('ascii', 0, 10), 'abcdefghij')
  t.equal(bl.toString('ascii', 3, 10), 'defghij')
  t.equal(bl.toString('ascii', 3, 6), 'def')
  t.equal(bl.toString('ascii', 3, 8), 'defgh')
  t.equal(bl.toString('ascii', 5, 10), '